---
title : "[운영체제] 3장 프로세스와 프로세스 관리"
date : 2024-04-08 23:34:00 +0900
categories : [운영체제, 정리]
tags : [operating system] #소문자만 가능
toc: true
toc_sticky: true
published : true
---

## 3장 프로세스와 프로세스 관리

---

### 3.1 프로세스 개요

#### 1.1 프로그램과 프로세스

프로세스란?

> 프로그램은 하드 디스크나 USB 등 저장 장치에 저장된 실행 가능한 파일이며, 프로그램이 메모리에 적재되어 실행 중일 때 프로세스라고 부른다.

*※ 프로세스 메모리에 적재되어 실행중인 프로그램*



##### 3.1.1 프로세스의 특징

* 메모리에 적재되어 **실행중인 프로그램**

* 실행에 필요한 메모리 할당하고 이곳에 **코드와 데이터 저장**
* 프로세스간 독립성 유지, **다른 프로세스 영역 접근 불가능**
* 프로세스마다 **고유 ID(프로세스 ID)** 할당됨
* 프로세스에 관한 정보는 커널에 의해 관리됨

* 프로세스는 생명주기를 지닌다 (실행-대기-잠자기 ... )

##### 3.1.2 프로세스 관리

* 프로세스는 운영체제가 응용프로그램의 실행을 위해 생성한 것으로, 운영체제는 프로세스의 생성에서 종료까지 모든 것을 관리한다

* 프로세스 생성, 실행, 일시 중단 및 재개, 프로세스 상태 관리, 프로세스 사이의 통신, 프로세스 사이의 동기화, 프로세스 종료 등 프로세스의 모든 행동을 처리한다.

##### 3.1.3 프로세스 관리

* 같은 프로그램을 여러번 실행하면 독립된 메모리 공간에서 실행되는 서로 다른 프로세스가 생성
* 이를 프로그램의 다중 인스턴스라고 함

##### 3.1.4 프로세스 주소 공간

* 프로세스의 구성 - <ins>**4개의 메모리 영역**</ins>으로 구성되며
  * Code, Data, Heap, Stack
* 프로세스 주소 공간 - CPU가 액세스 할 수 있는 전체 크기 
  * 사용자 공간 + 커널 공간
  * 가상 주소 공간 - 매핑 테이블을 통해 주소 관리

![가상주소공간](https://github.com/6-keem/BlogImageRepository/assets/113224939/6d9bf6e5-b91d-4a95-b802-af14c08b20d8)

### 3.2 커널의 프로세스 관리

##### 3.2.1 프로세스 테이블과 프로세스 제어 블록

* 프로세스 테이블 - 모든 프로세스의 정보를 <ins>**관리**</ins>
* 프로세스 제어 블록(PCB) - 프로세스 정보를 **<ins>저장</ins>**
  * 0 이상의 양의 정수 ...


*※ 프로세스 생성은 커널에서 수행*

![프로세스제어블록](https://github.com/6-keem/BlogImageRepository/assets/113224939/7fb8d23b-6a15-42dd-97fd-6fb8e2f26535)

Nice 값이 크면 우선순위가 낮음 (양보를 잘해준다)



#### 3.2.3 프로세스의 생명 주기와 상태 변이

![프로세스생명주기](https://github.com/6-keem/BlogImageRepository/assets/113224939/13299d88-ced2-4c03-abd0-cfd0c0ac0710)

* New 상태 - 프로세스가 새롭게 생성되었을 때의 상태

  * 커널은 새 프로세스의 **코드와 데이터를 메모리에 적재**하고, **PCB를 만들어 프로세스 테이블의 빈 항목에 등록**한다. 그리고 PCB에는 프로세스 상태를 New로 기록한다

  *※ 대부분 실행 준비가 완료되면 Ready로 전환 / 실시간 운영체제는 Deadline 내에 실행될 수 있는 Ready상태에 있는 프로세스 실행*

  

* Ready 상태 - 스케줄링을 기다리는 준비 상태로 커널에 있는 준비 큐(ready queue)에 들어간다. 

  * <mark>**CPU 스케줄링**</mark> : 하나의 프로세스를 선택하는 과정 

  *※ 기아 프로세스 : 장시간 선택을 받지 못한 프로세스*

  

* Running 상태 - CPU에 의해 현재 실행중인 프로세스

  * 실행이 완료되면 Terminated/Zombie 상태로 만듦

  * Running 상태에서 상태 변경할 때 스케줄링 실행 → PCB에 컨텍스트 저장 → 선택된 프로세스의 컨텍스트 스위칭 수행

    

* Blocked 또는 Wait 상태 - 자원 요칭 및 입출력 요청하고 완료를 기다리는 상태

  * 요청 받으면 CPU 스케줄링 실행하여 컨텍스트 스위칭



* Terminated/Zombie 상태 - 프로세스 종료 시 자원 모두 반환
  * 종료시 상태를 Terminated/Zombie 상태로 변경하지만 완전히 종료된 것은 아니며 부모 프로세스가 **종료 코드를 읽어가기 전**까지 PCB도 프로세스 테이블에 그대로 남겨둔다.



* Terminated/Out 상태
  * 부모 프로세스가 PCB에서 종료 코드를 읽어갈 때 커널은 Zombie 상태의 PCB를 시스템에서 제거하며 프로세스 테이블에서도 제거한다.



#### 3.2.4 프로세스 스케줄링

* 스레드 (thread)는 프로세스보다 작은 크기의 실행 단위로서, 개발자가 작업(task)을 구현하는 단위 이며 운영체제에 의해 스케줄링되는 단위이다.
* 오늘날 멀티스레드 운영체제에서 실행 단위는 프로세스가 아니라 스레드이다



----



### 3.3 프로세스의 계층 구조

#### 3.3.1 프로세스의 부모 - 자식 관계

* 모든 프로세스는 프로세스(부모)에 의해 생성

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/d53f21d2-0274-4418-bb64-8f9b138385d6" alt="프로세스부모관계" style="zoom:67%;" />

* 유휴 프로세스 (#0) - Ready 상태가 하나도 없을 때 실행되는 프로세스
  * 시스템 종료 과정을 책임짐
* init 프로세스 (#1) - sshd 프로세스 생성 및 로그인 확인 후 쉘 프로세스를 자식으로 생성
* kthreadd (#2) - 커널 모드로 실행되면서 커널의 기능을 돕는 프로세스



#### 3.3.3 부모자식 프로세스의 실행 관계

* fork() - <mark>자식 프로세스를 생성</mark>하는 시스템 호출 함수

* exit() - <mark>현재 프로세스의 종료</mark>를 처리하는 시스템 호출 함수

* wait() - 부모가 자식 프로세스가 <mark>종료할 때까지 기다리는</mark> 시스템 호출 함수

  

#### 3.3.4 좀비 프로세스: 종료후 방치된 자식 프로세스

> **종료하였지만, 부모가 종료코드를 읽지 않는 상태**로 시스템에 남아 있을 때, 이 프로세스를 좀비 프로세스라고 한다.



#### 3.3.5 고아프로세스와 입양

> 어떤 경우든, 부모가 먼저 종료한 자식 프로세스들을 고아 프로세스(orphan process)라고 부 른다.



#### 3.3.6 백그라운드 프로세스와 포그라운드 프로세스

* 사용자와 대화를 하느냐 하지 않느냐에 따라 나뉨



#### 3.3.7 CPU 집중 프로세스와 I/O 집중 프로세스

* CPU 집중 프로세스 - 프로세스의 작업이 대부분 계산 중심적인 일로 구성되어 실행의 많은 부분에 CPU가 활용

* I/O 집중 프로세스 - 프로세스의 작업 중 많은 부분 이 파일 입출력이나 네트워크 전송 등 입출력 작업

​	*※ CPU 바운드 프로세스, I/O 바운드 프로세스*



### 3.4 프로세스 제어 (fork, exec, wait, exit)

#### 3.4.1 프로세스생성과 fork()

* 시스템 부팅 과정에서 프로세스 생성 
* 로그인 시 쉘 프로세스 생성(bash, Windows 탐색기)
* 사용자 명령에 따라 응용프로그램 프로세스 생성(vi a.c)
* 배치(at, batch) 프로세스 생성
* 응용프로그램이 다중처리 (multitasking)를 위해 자식 프로세스 생성

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/652e0f99-1ed5-4c9e-854a-6a0fccc2acbe" alt="자식 프로세스가 생성되는 과정" style="zoom:80%;" />

#### 3.4.2 프로세스오버레이와 exec()

* 프로세스 오버레이(process overlay)는 현재 실행중인 프로세스의 주소 공간에 새로운 응 용프로그램을 적재하여 실행시키는 기법으로 exec() 시스템 호출이 사용된다

호출 프로세스의 모든 영역들이 사라진다. 그렇지만 호출 프로 세스의 PID는 그대로 계승된다.

![exec](https://github.com/6-keem/BlogImageRepository/assets/113224939/a9df7744-f451-4d21-ae2b-eca40a381ab6)

![execlp](https://github.com/6-keem/BlogImageRepository/assets/113224939/2bc3c3ae-276b-437d-8eea-f15c1ed38ed9)

#### 3.4.3 프로세스종료와프로세스종료 대기

##### 부모 프로세스가 자식의 종료 확인

* <mark>자식이 남긴 종료 이유를 전달받도록 하는데 목적</mark>

부모가 wait() 시스템 호 출을 시행하면, wait()의 커널 코드는 자식 프로세스의 PCB에서 종료코드를 읽고, 자식 프로 세스의 PCB를 삭제하고 프로세스 테이블의 항목도 제거한다.

##### 종류코드의 범위와 의미

* 0〜255 사이의 1바이트 숫자로

※ WEXITSTATUS 매크로로 하위 8비트 가져올 수 있음



### 4.4 좀비프로세스

* 자신이 남긴 종료코드가 부모에게 전달되지 않은 상태로 있을 때 좀비 프로세스라고 부른다

좀비 프로세스들이 존재하게 되는 이유는 부모 프로세스를 작성한 개발자의 무지에서 비롯되 거나 부모 프로세스에 오류가 발생하여 wait()를 부르지 않고 비정상 종료해버린 경우가 대부 분이다.

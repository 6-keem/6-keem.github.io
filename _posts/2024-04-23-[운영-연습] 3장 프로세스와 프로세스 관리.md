---
title : "[운영체제/연습문제] 3장 프로세스와 프로세스 관리"
date : 2024-04-23 00:02:00 +0900
categories : [운영체제, 연습문제]
tags : [operating system] #소문자만 가능
toc: true
toc_sticky: true
published : true
---

### 1. 다음 글에서 프로세스와 프로그램 중에서 선택하라. 

#### (프로그램)은(는) 컴파일되어 실행 가능한 형태로 저장 장치에 저장된 상태일 때 부르는 용어이며, 

#### (프로세스)은(는) 메모리에 적재되어 실행 중인 상태일 때 부르는 용어이다.

### 2. 프로세스의 특징을 설명한 것 중 맞는 것은? 

> ④ 프로세스를 스케줄링하는 것은 커널의 기능이다

### 3. 프로세스에 대한 설명으로 틀린 것은? 

> ① 동일한 프로그램이 실행되어 생성된 프로세스는 항상 동일한 프로세스 번호를 할당받는다

### 4. PCB에 들어 있는정보가아닌 것은? 

> ④프로세스이름 

### 5. 프로세스의 종료코드는 어디에저장되는가? 

> ① 프로세스의 PCB

### 6. 프로세스가 종료될 때, 커널이 프로세스 테이블 항목이나 PCB를 즉각 삭제하지 않는 이유는 무엇인가?

> ② 프로세스 종료코드를 부모 프로세스가 읽어갈 때까지 기다리기 위해

### 7. 32비트 CPU에 대해 다음에 답하여라.

#### (I) CPU의 주소선 개수는?  - 32개

#### (2) CPU가 액세스 가능한 메모리의 최대량은? - 4GB

#### (3) 이 CPU글 사용할 때 프로세스의 주소 공간 크기는?  - 4GB

### 8. 프로세스의 주소 공간에 대한 설명으로 맞는 것은? 

> ① 프로세스가 실행되는 동안 접근할 수 있는 메모리의 최대 범위이다.

### 9. 프로세스가 메모리에 적재될 때 프로세스를 구성하는 4개의 영역은 무엇인가? 

> Code, Data, Heap, Stack

### 10. 운영체제는 프로세스를 코드, 데이터, 힙, 스택의 4 영역으로 구성한다. 다음은 어느 영역에 형성되는가? 

#### (1) 전역 변수 - Data

#### (2) 지역 변수 - Stack

#### (3) C++에서 new 연산자나 C 프로그램에서 malloc() 함수를 호출하여 할당받은 메모리  - Heap

#### (4) 사용자가 작성한 함수 코드 - Code

#### (5) 라이브러리에 작성된 함수 - Code 

#### (6) 라이브러리 함수에 선언된 지역 변수들 - Stack

### 11. 프로세스가 적재된 이후 실행 과정 동안 크기가 변하는 않는 영역을 있는 대로 골라라? 

> ①코드영역 ②데이터 영역

### 12. printf()는 C 프로그램에서 화면 출력을 위해 사용되는 C 표준 라이브러리 함수이다. 다음 질문에 답하라. 

### (1) printf() 함수의 코드는 프로세스의 코드 영역에 포함되는가? 

> 그렇다

#### (2) printf() 함수 내에 선언된 지역 변수들은 프로세스의 어느 영역에 포함되는가? 

> ④스택 

#### (3) printf() 함수의 코드와 지역 변수들은 사용자 공간에 적재되는가, 커널 공간에 적재되는가? 

> 표준 라이브러리 함수는 컴파일 시 하나의 파일로 링크되어 사용자 공간에 적재 및 실행된다. 

### 13. 프로세스의 주소 공간은 0번지부터 시작되어 연속적인 번지로 이루어진다. 만일 3개의 프로세스가 메모리에 적재된 채 동시에 실행된다고 하면, 모든 프로세스가 0번지에서 시작하므로 프로세스들 사이에 번지 충돌이 발생하고 메모 리 충돌이 발생할 것 같다. 운영체제는 어떻게 이 문제를 해결하는가?

> 가상 주소를 사용하여 매핑 테이블을 통해 실제 메모리 위치에 접근하기 때문에 충돌하지 않는다.

### 14. 프로세스 스케줄링에는 어떤 상태의 프로세스들이 대상이 되는가?

> ① Ready 상태 

### 15. 커널은 현재 실행 중인 프로세스가 입출력을 요청하면 어떤 상태로 전이시키는가? 

> ② Blocked 상태

### 16. 프로세스는 실행 중 다음 각 경우에 어떤 상태로 바뀌는가? 

#### (1) yield() 시스템 호출을 불러 스스로 실행을 중단하고 다른 프로세스에게 양보할 때

> Running -> Ready

#### (2) sleep() 시스템 호출을 불러 1초 동안 잠을 잘 때 

> Running -> Blocked

#### (3) exit() 시스템 호출을 불러 종료할 때 

> Running -> Terminated/Zombie

#### (4) 프로세스에게 할당된 타임 슬라이스가 다 되었을 때 

> Running -> Ready

### 17. PCB 내에 프로세스가 열어 놓은 파일에 관한 정보가 저장되는 것으로 미루어 다음 중 틀리게 설명한 것은?

> ④ 한 프로세스가 열어 놓은 파일을 다른 프로세스가 입출력할 수 있다. 

### 18. 다음 중 자식 프로세스를 생성하는데 사용되는 시스템 호출은? 

> ① fork() 

### 19. wait() 시스템 호출에 대해 잘 설명한 것은? 

> ① 자식 프로세스가 종료할 때까지 대기한다.

### 20. 부모 프로세스가 wait() 시스템 호출을 부르기 전, 자식 프로세스가 먼저 종료할 때 상황에 맞게 설명된 것은? 

> ① 커널은 자식 프로세스를 좀비 프로세스로 만든다. 

### 21. 좀비 상태의 프로세스에 대한 설명 중 틀린 것은? 

> ① 좀비 프로세스는 시스템의 성능을 심각하게 떨어뜨린다. 

### 22. 유닉스 계열의 운영체제에서 #1 프로세스를 무엇이라고 부르는가? 

> ② init

### 23. 유닉스 계열의 운영체제에서 모든 사용자 프로세스의 조상은 누구인가? 

> init

### 24. Windows에서 #0 프로세스인 시스템 유휴 프로세스(system idle process)나 리눅스의 #0 idle 프로세스의 역할은 무엇인가? 

> Ready 큐에 대기중인 프로세스가 없을 경우 우선순위가 제일 낮은 idle 프로세스를 실행하여 실행할 프로세스가 없는 것을 방지한다.

### 25. 다음은 어떤 프로세스를 설명하는지적어라. 

#### (1) 부모 프로세스가 먼저 종료한 자식 프로세스 

> 고아 프로세스

#### (2) 종료할 때 종료코드를 남겨 놓았지만 부모 프로세스가 읽어가지 않고 있을 때, 종료한 자식 프로세스 

> 좀비 프로세스

#### (3) 입출력 작업이 계산 작업보다 월등히 많은 프로세스 

> I/O 집중 프로세스

#### (4) 계산 작업이 입출력 작업보다 월등히 많은 프로세스 

> CPU 집중 프로세스

#### (5) 사용자와 대화가 필요하지 않고 낮은 우선순위로 실행되는 프로세스 

> Background 프로세스

### 26. 시스템에 무한히 많은 프로세스가 생성되지 못하는 이유가 구체적으로 무엇일까? 

> 프로세스 테이블의 크기가 한정적, 8비트로 총 256개의 프로세스만 관리할 수 있기 때문이다.

### 27. main()에서 3을 리턴하는 three라는 C 프로그램을 작성하였다. 쉘에서 다음과 같이 실행시키면, main()에서 리 턴한 값 3은 누구에게 전달되는가? $ ./three $ 

> ③ 쉘

### 28. 종료코드의 목적은 무엇인가? 

> ② 프로세스가 어떤 상태로 종료함을 부모 프로세스에게 전달하기 위해
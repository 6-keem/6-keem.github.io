---
title : "[운영체제] 2장 컴퓨터 시스템과 운영체제 (2)"
date : 2024-03-24 16:39:00 +0900
categories : [운영체제, 정리]
tags : [operating system] #소문자만 가능
toc: true
toc_sticky: true
published : true
---

## 3. 커널과 시스템 호출

---

### 3.1 응용프로그램의 자원 접근문제

응용 프로그램이 자원에 대한 직접적인 접근 권한을 가지게 된다면 다음과 같은 문제가 발생할 수 있다.

* 응용프로그램이 다른 응용프로그램이 적재된 **메모리를 덮어써버리거나,** 다른 응용프로그램이 생성 한 **파일을 삭제**하거나 하는 등 **다른 응용프로그램의 실행을 망칠 수 있다.**
* • 응용프로그램이 운영체제 커널이 적재된 메모리를 액세스하여 **커널의 주요 데이터를 훼손**하는 등 **컴퓨터 시스템이 복구 불가능**한 심각한 문제에 빠질 수 있다.

이를 방지하기 위해 

* 응용 프로그램과 운영체제 커널의 영역을 확실히 구분하기 위해 <ins>**(1) 사용자 공간**</ins>과 <ins>**커널 공간**</ins>으로 나눈다.

* 응용 프로그램이 커널 공간을 함부로 접근할 수 없도록 하기 위해 **<ins>(2) 사용자 모드</ins>**와 **<ins>커널 모드</ins>**로 나눈다.

### 3.2 사용자 공간과 커널 공간

> CPU로 액세스할 수 있는 전체 주소 공간을 사용자 공간(user space)과 커널 공 간(kernel space)으로 분리하여 운영한다

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/1a3897a2-5408-4483-a97f-86c29ccc96c7" alt="메모리구조" style="zoom:67%;" />

사용자 주소는 0번부터이다. (**가상 주소** - 컴파일러에 의해 결정)

*※ Windows 운영체제는 크기가 크고 제공하는 기능 등이 많아 이를 위한 커널 공간이 크다. 커널 공간이 작으면 SW를 위한 공간이 커짐* 

* 사용자 공간 - **응용 프로그램**을 위한 영역

* 커널 공간 - 커널 코드, 데이터, 커널 함수 실행을 위한 스택 영역, 디바이스 드라이버 등이 탑재한 영역

  

그러면 다음과 같이 공간을 나누어 둔 이유는 무엇일까?

> **바로 응용프로그램으로부터 커널 코드와 데이터를 훔쳐보거나 훼손하는 것을 방지**하기 위해서이다.

만약 커널이 개방되어 있다면 다음과 같은 문제가 발생할 수 있다.

* 바이러스 침범, 시스템 훼손, 시스템 중단 등 심각한 문제가 발생할 수 있다.

*※ 응용 프로그램이 커널 영역 침범시 예외 발생시키고 종료된다.*



#### 3.2.3 사용자 공간과 커널 공간은 가상 주소 공간이다.

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/b3202248-120b-4d6e-ac78-c957965b8400" alt="가상주소공간" style="zoom:67%;" />

> 응용프로그램이 사용하는 이 번지들은 운영체제가 응용프로그램에게 만들어놓은 가상 주소이다. 

이를 보면 두 가지 의문점이 생긴다.

* 응용 프로그램이 사용하는 공간간의 충돌이 발생하지 않는지?
* 컴퓨터에 장착된 RAM의 용량이 4GB보다 작으면 어떻게 되는지?

공간의 충돌 문제

- 운영체제는 각 응용프로그램의 **가상 주소 공간**을 **물리 메모리 공간으로 매핑**시켜 가상 주소 공간의 **충돌을 해결**한다. 운영체제는 각 **응용프로그램(프로세스)마다 커널 공간에 매핑 테이블을 두고** 사용자 공간을 **물리 메모리(RAM)의 공간**으로 매핑한다

RAM 용량 부족 문제

- 메모리의 용량을 확장하기 위한 가상 메모리 (보조기억장치를) 주기억장치처럼 사용 이후 9장(가상 메모리 기법이라고 부름)에서 설명

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/3e67af45-effe-4c26-999b-d293d7ef02d3" alt="가상주소공간테이블매핑" style="zoom:67%;" />

*※ 컴퓨터 구조 가상 기억장치 페이징 기법 참조 (매핑함수, 페이징 기법 등)* 

Q. 매핑 테이블 공유하지 않는 이유 컴파일러를 단순화하기 위함?

> No. 각 프로세스마다 변수와 함수가 있기 때문에 구별하기 위함?



---



### 3.3 CPU의 사용자 모드와 커널 모드

CPU는 사용자 모드와 커널 모드 중 한 모드에서 실행된다.

* 응용 프로그램 - 사용자 모드 (Mode Bit = 1)
* 커널 코드 - 커널 모드 (Mode Bit = 0)

*※시스템 호출 시 커널 모드로 전환되며 **CPU내의 모드 레지스터**에 설정된다.*

| 모드                           | 사용자 모드                                    | 커널 모드                            |
| ------------------------------ | ---------------------------------------------- | ------------------------------------ |
| **CPU의 메모리 액세스 범위**   | 사용자 공간에 국한 / **커널 공간 액세스 불가** | 커널 공간을 포함한 모든 메모리 공간  |
| **CPU의 하드웨어 액세스 여부** | 불가능                                         | 가능                                 |
| **CPU가 처리 가능한 명령**     | **특권 명령을 제외**한 모든 CPU 명령           | 특권 명령을 **포함**한 모든 CPU 명령 |
| **오류 발생 시 처리**          | 응용 프로그램 실행 종료 -> **안전**            | **심각한 오류** -> 시스템 종료       |

#### 3.3.1 사용자 모드

* 사용자 모드에서 **커널 공간을 액세스**하려고 하면 **예외를 발생**시키고 **프로세스를 종료**된다.

* 사용자 모드에서는 특권 명령(privileged instruction)을 실행할 수 없다.

  *※ 특권 명령은 입출력 장치나 타이머, 인터럽트 처리, 시스템 중단 등 특별한 목적으로 설계된 CPU 기계 명령이다.*

#### 3.3.2 커널 모드 (특권 모드)

* 커널 모드에서는 모든 메모리 공간을 액세스할 수 있다.
* 커널 모드에서는 특권 명령을 실행할 수 있다.

#### 3.3.3 사용자 모드에서 커널 모드로 전환

다음 두 가지는 모드가 전환되는 경우이다. 

* 시스템 호출 (System Call)
* 인터럽트 (Interrupt)

시스템 호출 - 응용 프로그램이 하드웨어를 조작하는 유일한 방법

인터럽트 - 하드웨어가 커널에 타이머 완료, 인터럽트 요청 등을 알리는 방법

#### 3.3.4 특권 명령

* I/O 명령

  하드웨어들을 제어하거나 입출력 장치나 저장장치를 제어하고 읽기 쓰기에 사용되는 CPU 기계 명령

​		I/O 명령들은 하드웨어 장치를 직접 접근하므로 커널 모드에서 실행되어야 하는 특권 명령이다

* Halt 명령

​		CPU의 작동을 중지시키고 CPU를 유휴(idle) 상태로 만든다. 

​		CPU는 아무 인터럽트나 받을 때까지 아무 명령도 실행하지 않기 때문에 전력 소모를 줄일 수 있다

* 인터럽트 플래그켜고 끄기

​		인터럽트가 발생할 때 처리할 지 아니면 무시할 지를 나타내는 비트를 가지 고 있는데 이를 인터럽트 플래그(interr니pt flag)라고 부른다.

* 타이머 설정

  타이머를 설정하는 명령은 특권 명령이

* 컨텍스트스위칭

  CPU의 레지스터들을 커널 영역에 저장하고, 저장된 컨텍스트 정보를 CPU 레지스터에 복귀시키는 컨텍스트 스위칭 명령은 커널 모드에서 실행되는 특권 명령이다.

  

*※ IDLE 프로세스 내 HALT 명령이 존재하며 HALT 명령을 실행하면 CPU가 프리징된다.*

#### 3.3.5 다양한 이슈

* 사용자 모드와 커널 모드는 CPU에 의해 구현되는가 커널에 의해 구현되는가?

  > **CPU에 의해 구현**되어 운영체제가 활용하는 기능

​		*※ CPU는 모드 레지스터를 가짐*

* 운영체제가 사용자 모드와 커널 모드로 나누어 작동시키는 이유는?

  >**커널** 코드와 데이터에 대한 **보안과 보호**를 위해

* 응용프로그램이 커널 기능을 어떻게 활용할 수 있는가?

  > **시스템 호출**을 통해 커널 코드 호출한다.



---



### 3.4 커널의 실체

> 커널은 부팅 시에 커널 공간에 적재되는 **함수들과 데이터**들의 집합

※ 프로세스 A가 시스템 호출을 통해 커널 함수가 실행됐다고 할 때 이 때 프로세스 A가 실행중이라고 한다.

​	→ <ins>**커널은 프로세스가 아니기**</ins> 때문에



* 커널은 프로세스인가? 

  ``` No. 시스템 관리를 위한 함수와 데이터의 집합으로, 스스로 실행되는 프로세스가 아니다 ```

  *※ 그러면 커널은 어떻게 프로세스 스케줄링을 하는 것일까?*

  ​	→ 커널내에 *스케줄링 함수*를 호출한다.

* 커널은 실행중이다?

  ``` 아니다. ```

* 커널은 스택이나 힙을 가지는가?

  ``` No. 프로세스가 시스템 호출을 통해 커널에 진입하면 자신에게 할당된 커널 스택을 활용하여 커널에 있는 함수를 호출할 때 매개 변수나 지역 변수를 저장 ```

​		```스레드가 생성될 때 스레드마다 커널 스택이 할당 ```



---



### 3.5 응용 프로그램 빌딩

**라이브러리** 

* 응용 프로그램에서 활용할 수 있도록 미리 함수를 작성, 컴파일된 바이너리 형태의 파일

​	개발자의 **개발 시간을 단축**시키고 **커널의 함수**를 **대신 호출**하는 역할을 함

라이브러리는 다음 두 가지가 있다. 

* 표준 라이브러리 
* 시스템 호출 라이브러리(**시스템 호출 함수, 커널 API**) - 커널 함수를 실행하는 함수

#### 3.5.1 사용자 코드와 라이브러리 코드의 링킹

> 사용자가 작성한 프로그램에 의해 호출되는 라이브러리가 결합되어 하나의 파일로 저장된다.

* 사용자가 작성한 부분과 표준 라이브러리는 **사용자 공간**에 위치하며, **모두 사용자 모드에서 실행**된다.
  * 표준 라이브러리 - 함수 호출(function call)을 통해 코드 실행
  * 시스템 호출 라이브러리 - 시스템 호출 (System call)를 통해 커널 코드 사용

#### 3.5.2 함수 호출(function call)로 라이브러리 활용

* 함수 호출 과정에서는 **사용자 모드에서 변경되지 않는다**.

#### 3.5.3 시스템 호출(system call)로 커널 코드 호출

* 시스템 호출 라이브러리에 작성된 **시스템 호출 함수**를 통해 간접적으로 **커널 함수를 호출**한다.
  * 시스템 호출 함수는 고유 번호(**시스템 호출 번호**)로 커널 함수를 구분한다.
* 시스템 호출의 동작
  * CPU 모드를 **커널 모드로 바꾸고**, 커널 공간에 있는 **시스템 호출 핸들러**에 함수의 **고유 ID**를 넘겨주어 실행시킨다. 

#### 3.5.4 응용프로그램이 라이브러리와 커널 코드를 활용하는 과정

* printf()는 버퍼에 따라 시스템 호출 함수인 write()가 실행될 수도 안될 수도 있다. (이후 자세히 설명)
* open()은 시스템 호출을 유발하는데, 커널 함수의 **고유 ID가 시스템 호출 핸들러에게 전달**된다.



---



### 3.6 시스템 호출 (트랩)

> CPU의 실행 모드를 커널 모드로 전환하고 커널 코드로 진입



### 3.7 시스템 호출 과정 사례

![시스템 호출 과정](https://github.com/6-keem/BlogImageRepository/assets/113224939/7dc4452a-26a0-4b3a-8a30-538045e010ff)

### 3.7 시스템 호출에 따른 비용

시스템 호출은 함수 호출에 비해 많은 시간 비용을 초래한다. 따라서 **시스템 호출을 많이 실행**하는 프로그램은 **그만큼 실행 속도가 느리다.**

- 1KB의 파일을 100 Byte 씩 읽는다고 가정하였을 때 표준 라이브러리 함수인 fread()의 경우 시스템 호출 함수 read()를 호출하여 디스크의 한 블럭(4KB)을 라이브러리 입력 버퍼에 읽어와 <mark>1번 시스템 호출이 발생</mark>하지만 시스템 호출 함수인 read()를 사용할 경우 디스크에서 100바이트 씩 10번 읽어와 <mark>시스템 호출이 10번 발생</mark>한다. 

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/9a6af303-b0ef-4a1e-a8ad-dbbccd408632" alt="시스템호출비용" style="zoom:150%;" />







## 4. 운영체제와 인터럽트

---

> 인터럽트는 장치들이 어떤 상황이 발생하였음 을 CPU에게 알리는 하드웨어적 방법이다. 

- CPU가 인터럽트 신호를 받으면, CPU는 프로그램의 실행을 멈추고 돌아올 주소를 저장한 다음, 발생한 인터럽트를 처리하는 서비스 루틴을 실행한다. 서 비스 루틴이 끝나면 저장해둔 주소로 돌아가서 이전 프로그램의 실행을 계속한다.

인터럽트의 종류에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다.



### 4.2 컴퓨터에서 인터럽트 활용

컴퓨터에서 인터럽트가 활용되는 경우는 다양하다. 예를 들면 다음과 같다.

- 마우스를 움직이거나 클릭하는 등 마우스 조작 
- 키보드 입력 • 네트워크로부터 데이터 도착
- 하드 디스크의 쓰기 종료
- 시스템 클럭으로부터 일정한 시간 간격으로 알림
- 컴퓨터의 리셋 버튼 누르기 
- USB 메모리 부착 혹은 해제



### 4.3 인터럽트 발생 및 처리 과정

- 용어 정리
  - I/O APIC - **여러 입출력 장치로부터 인터럽트**를 받기 위해, CPU와 입출력 창치 사이 존재하는 인터럽트 제어기
  - Local APIC - I/O APIC로부터 인터럽트 정보를 받아 CPU의 INTR 핀에 직접 인터럽트 신호를 발생시키는 장치

<img src="https://github.com/6-keem/BlogImageRepository/assets/113224939/0de582cb-5542-49dc-aa1d-7cd0c85dfa9c" alt="인터럽트 처리과정" style="zoom:80%;" />

#### 4.3.1 인터럽트 벡터 테이블

> 인터럽트 벡터 테이블은 256개의 인터럽트에 대해 인터럽트 서비스 루틴（ISR）의 주소를 저장 하고 있는 테이블이다

- 인터럽트 벡터 테이블은 커널 영역에 저장되어 ISR에 대한 주소를 담고 있으며 CPU가 ISR 주소를 알아낼 때 사용된다.

※ 인터럽트 발생 시 운영체제는 특정 Local APIC로 인터럽트를 보내 처리 시키기도 하는데 이를 **인터럽트 친화성**이라 부른다.



### 4.4 인터럽트 서비스 루틴과 운영체제

- 인터럽트 서비스 루틴은 인터럽트 핸들러라고 불리기도 하는데 이는 **디바이스 드라이버나 커널 코드**에 들어있다.

> 디바이스 드라이버는 장치를 제어하여 장치로부터 입출력을 수행하는 프로그램이다.

*※ 일반적으로 디바이스 드라이버에 해당 장치에 대한 인터럽트를 처리하는 코드가 들어있음*

*※ 본래 디바이스 드라이버는 커널 영역에 적재되었지만 잘못 작성된 디바이스 드라이버로 인해 시스템에 오류가 생기는 문제로 최근에는 사용자 공간에 적재할 수 있는 디바이스도 허용하고 있다.*



### 4.5 인터럽트는 다중 프로그래밍의 키

> I/O 발생하면 CPU는 해당 프로세스를 중단 상태로 만들고 다른 프로세스를 실행하여 활용률을 높인다.
>
> 인터럽트가 발생하여 I/O가 끝났다는 것을 CPU가 통보 받으면 현재 실행중인 프로세스를 중단시키고 다시 원래 실행했던 프로세스를 실행한다.
>
> 인터럽트는 입출력 장 치와 CPU가 동시에 각자의 일을 실행하게 하여 컴퓨터 시스템이 효율적으로 작동하게 한다. CPU 를 보다 효율적으로 사용하여 <mark><ins>CPU 활용률이 높아지고 시스템의 처리율</ins></mark>도 높아진다.

